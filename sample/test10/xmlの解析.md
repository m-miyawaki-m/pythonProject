ご指摘の通り、**XML 解析**と**SQL 解析**は分けて実装する方が効率的かつ保守性が高くなります。さらに、**サブクエリ**や**集約関数**の扱いについても個別に検討し、適切に対応する必要があります。

以下に、タスクを再整理し、分割する形で XML 解析と SQL 解析の役割、およびサブクエリや集約関数の扱いを表形式でまとめます。

---

## **XML 解析と SQL 解析の分割：必要事項と実装ポイント**

### **1. XML 解析フェーズ**

| **No** | **検討項目**               | **必要な情報・内容**                                                           | **実装ポイント**                   | **成果物**                    |
| ------ | -------------------------- | ------------------------------------------------------------------------------ | ---------------------------------- | ----------------------------- |
| **1**  | **対象タグの抽出**         | `<select>`, `<insert>`, `<update>`, `<delete>`, `<sql>`, `<include>`タグを抽出 | `xml.etree.ElementTree`を使用      | タグ名、ID、SQL 文            |
| **2**  | **タグの属性取得**         | 各タグの`id`、`parameterType`、`resultType`を取得                              | 属性情報を辞書形式で格納           | ID、Namespace、パラメータ情報 |
| **3**  | **SQL 文の収集**           | タグ内の SQL 文をそのまま収集する                                              | `itertext()`を使ってテキストを取得 | SQL 文                        |
| **4**  | **<sql>と<include>の展開** | `<sql>`タグの定義と`<include>`タグの参照解決                                   | 再帰的に展開し、依存関係を記録     | 展開後の SQL 文、出典情報     |
| **5**  | **XML ファイルの出力管理** | XML ファイルごとに解析結果を出力                                               | ファイル名ごとにデータをまとめる   | 中間データ（CSV/JSON）        |

---

### **2. SQL 解析フェーズ**

| **No** | **検討項目**               | **必要な情報・内容**                             | **実装ポイント**                           | **成果物**               |
| ------ | -------------------------- | ------------------------------------------------ | ------------------------------------------ | ------------------------ |
| **1**  | **SQL の構文解析**         | SQL 文をトークン化し、構造を解析                 | `sqlparse`を使用し、トークンごとに分類     | トークンリスト           |
| **2**  | **テーブル名の抽出**       | `FROM`句、`JOIN`句からテーブル名を取得           | エイリアスがあれば実テーブル名に解決       | テーブル名               |
| **3**  | **カラム名の解析**         | SELECT 句、WHERE 句、INSERT 句のカラム名取得     | トークン解析でカラム名を特定               | カラム名リスト           |
| **4**  | **サブクエリの対応**       | SQL 文内のサブクエリを再帰的に解析               | サブクエリの`SELECT`や`FROM`句を特定       | サブクエリ情報、親子構造 |
| **5**  | **集約関数の解析**         | `SUM`, `MAX`, `MIN`, `COUNT`などの集約関数の検出 | 関数名・引数を特定し、カラム名にマッピング | 関数情報リスト           |
| **6**  | **WHERE 句・条件式の解析** | WHERE 句の条件式、パラメータを抽出               | 正規表現で`#{param}`や条件をリスト化       | 条件式、パラメータリスト |
| **7**  | **出力データの構造化**     | SQL 解析結果をテーブルごとにまとめる             | テーブル名、カラム名、条件式をデータ化     | SQL 解析結果（CSV/JSON） |

---

## **サブクエリと集約関数の具体的な扱い**

### **1. サブクエリの扱い**

- **要件**：

  - サブクエリは独立した SQL 構造として解析し、親 SQL との関連を記録する。
  - サブクエリ内のテーブル名やカラム名も正確に取得する。

- **実装ポイント**：

  - `sqlparse`を再帰的に利用し、サブクエリの`SELECT`句や`FROM`句を解析。
  - 親 SQL とサブクエリの階層関係を保持する。

- **出力項目例**：
  | SQL ID | サブクエリ階層 | テーブル名 | カラム名 | 条件式 |
  |-----------|---------------|-------------|----------|-------------|
  | findUser | 0（親） | USER_DATA | id | u.id = 1 |
  | findUser | 1（サブ） | SUB_USER | sub_id | sub.age > 20|

---

### **2. 集約関数の扱い**

- **要件**：

  - `SUM`, `MAX`, `MIN`, `AVG`, `COUNT` などの集約関数とその引数を特定する。
  - 関数内に使用されているカラム名を解析し、結果に含める。

- **実装ポイント**：

  - `sqlparse`で`Function`トークンを検出し、関数名と引数を取得。
  - 引数内のカラム名は、エイリアスを解決して正確なテーブル名に関連付ける。

- **出力項目例**：
  | SQL ID | 関数名 | 引数 | テーブル名 | カラム名 |
  |-----------|----------|------------|------------|-----------|
  | findMaxId | MAX | id | USER_DATA | id |
  | findCount | COUNT | _ | USER_DATA | _ |

---

## **全体フロー**

### **ステップ 1: XML 解析**

1. MyBatis XML から対象タグ、SQL 文、出典情報を抽出。
2. `<sql>`タグの展開や`<include>`タグの参照解決を行う。
3. 中間データとしてファイル単位で JSON/CSV に出力。

### **ステップ 2: SQL 解析**

1. SQL 文を`sqlparse`でトークン化し、テーブル名・カラム名・条件式を抽出。
2. サブクエリを再帰的に解析し、親 SQL と階層関係を記録。
3. 集約関数を検出し、関数名とカラム名を特定。

### **ステップ 3: 結合**

1. XML 解析結果と SQL 解析結果をマージ。
2. CRUD 操作と関連情報を統合し、最終的な CRUD 図を作成。

---

## **まとめ**

- **XML 解析と SQL 解析を分離**することで、役割が明確になり、保守性が向上します。
- **サブクエリ**と**集約関数**への対応を実装することで、複雑な SQL にも対応可能になります。
- 各フェーズの出力は中間データ（JSON/CSV）として整理し、最終的に統合することで CRUD 図作成の品質を高めます。
