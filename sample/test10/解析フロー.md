ご要望の内容は非常に合理的で、**差分解析**と**完全解析**を CI/CD パイプラインに組み込むことで、効率的に CRUD 図の作成を実現できます。以下の方針で構築することを提案します。

---

## **1. 差分解析の実現方法**

### **目的**

- **コミットのタイミング**で、変更があった Java クラスや MyBatis XML ファイルに対してのみ解析処理を実行する。

### **手順**

1. **Git の差分取得**

   - コミット間の差分から、修正・追加・削除があったファイルのリストを取得します。

   **具体例（Git コマンド）**：

   ```bash
   git diff --name-only HEAD~1 HEAD
   ```

   - `HEAD~1`は直前のコミットとの差分を指します。
   - ファイル一覧が出力されるため、`*.java`と`*.xml`にフィルタリングします。

2. **差分ファイルの解析**

   - 修正・追加された Java クラスや XML ファイルのみを対象に CRUD 図作成処理を走らせます。
   - **Java クラス** → javalang で解析
   - **XML ファイル** → `xml.etree.ElementTree`と`sqlparse`で解析

3. **関連ファイルの特定**

   - Java クラスと XML は関連付けされているため、**修正された XML に関連する Java クラス**も対象に含めるようにします。

   **例**：

   - Java クラス内で`MyBatis`の`namespace`を呼び出している箇所を検索。
   - 修正された XML の`namespace`と一致する Java クラスを差分解析対象に追加。

4. **CRUD 図の部分更新**
   - 解析結果を既存の CRUD 図にマージして、部分的に更新する仕組みを実装します。

---

## **2. 定期実行時の完全解析**

### **目的**

- **土日や週末**などコミットがない場合、全ての Java クラスと XML ファイルを対象に完全解析を実行し、CRUD 図を再生成します。

### **実行タイミング**

- GitHub Actions, Jenkins, GitLab CI などの CI/CD ツールで**スケジュール設定**を行います。
  - 例：毎週土曜深夜 1 時に完全解析を実行。
  ```yaml
  schedule:
    - cron: "0 1 * * 6" # 毎週土曜 1:00AM
  ```

---

## **3. CI/CD パイプラインのフロー**

| **ステップ**              | **処理内容**                                                                                |
| ------------------------- | ------------------------------------------------------------------------------------------- |
| **Step 1: 差分の抽出**    | `git diff`で変更があったファイルのリストを取得し、`*.java`および`*.xml`に絞る。             |
| **Step 2: 差分解析**      | 修正があった Java クラスと XML ファイル、および関連するファイルを対象に CRUD 図を部分更新。 |
| **Step 3: 完全解析**      | 土日にスケジュール実行で全ファイルを対象に CRUD 図を再生成。                                |
| **Step 4: CRUD 図の出力** | CSV や EA 用 XML ファイルを生成し、成果物として保存。                                       |
| **Step 5: 差分マージ**    | 既存の CRUD 図と差分解析結果をマージし、最新状態に更新。                                    |

---

## **4. CI/CD の具体的な実装例**

### **GitHub Actions の場合**

以下は、**コミット時**の差分解析と**週末**の完全解析を実装する GitHub Actions のサンプルです。

```yaml
name: CRUD解析パイプライン

on:
  push:
    branches:
      - main
  schedule:
    - cron: "0 1 * * 6" # 毎週土曜 1:00AMに完全解析

jobs:
  diff-analysis:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - name: リポジトリをチェックアウト
        uses: actions/checkout@v3

      - name: 差分ファイル取得
        run: |
          git fetch origin main
          git diff --name-only HEAD~1 HEAD > diff_files.txt
          cat diff_files.txt | grep -E '\.java|\.xml' > target_files.txt

      - name: 差分解析の実行
        run: |
          python main.py --files target_files.txt  # 差分対象のみ解析する

  full-analysis:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: リポジトリをチェックアウト
        uses: actions/checkout@v3

      - name: 完全解析の実行
        run: |
          python main.py --full  # 全ファイルを対象に解析
```

---

## **5. 注意点と最適化**

1. **差分抽出の効率化**：

   - 差分が多い場合、並列処理を導入して解析時間を短縮します（Python の`concurrent.futures`を活用）。

2. **部分更新の整合性**：

   - 既存の CRUD 図に差分結果をマージする際、重複や矛盾が生じないよう適切に処理します。

3. **完全解析の頻度**：
   - 土日以外でも月 1 回の完全解析を設定し、万が一の差分漏れをカバーします。

---

## **まとめ**

- **コミット時** → Git の差分取得で変更された Java クラス・XML だけを解析し、CRUD 図を部分更新。
- **土日** → 定期実行で全ファイルを対象に完全解析を行い、CRUD 図を最新化。

この設計により、**毎日の負荷を最小限に抑えつつ、CRUD 図の鮮度と正確性を維持**することができます。

その通りです。**Java 側（Logic・DAO）** と **MyBatis XML** の解析結果を **クラス・ファイル単位** で出力することで、差分解析や部分更新が容易になります。以下の点を考慮して設計すると、効率的に CRUD 図を管理できます。

---

## **1. クラス・ファイル単位での CSV 出力の利点**

1. **差分処理が容易**：

   - ファイル単位の出力があれば、Git の差分抽出で取得したファイル名と照合し、対象のファイルだけ再解析できます。
   - 差分があるファイルの CRUD 情報のみを更新する仕組みを構築できます。

2. **パフォーマンス向上**：

   - 全体の解析を毎回行う必要がなく、対象ファイルのみ処理するため処理時間を短縮できます。

3. **整合性の担保**：
   - クラス単位・ファイル単位のデータを出力しておくことで、マージ処理時の整合性を保ちやすくなります。

---

## **2. CSV 出力フォーマット**

### **Java 側（Logic/DAO）の CSV 出力**

| **カラム名**       | **説明**                        |
| ------------------ | ------------------------------- |
| クラス名           | Logic や DAO クラスの名前       |
| ファイル名         | Java ファイルのパス             |
| 呼び出し元メソッド | 修正・追加があったメソッド名    |
| 呼び出し先メソッド | DAO の呼び出し先メソッド名      |
| Dao クラス         | DAO クラス名                    |
| Dao メソッド       | MyBatis を呼び出すメソッド名    |
| CRUD 種別          | CREATE / READ / UPDATE / DELETE |
| MyBatis Namespace  | MyBatis XML の Namespace        |
| MyBatis Id         | SQL の ID                       |
| パラメータ         | SQL に渡されるパラメータ        |

---

### **MyBatis XML の CSV 出力**

| **カラム名** | **説明**                            |
| ------------ | ----------------------------------- |
| ファイル名   | MyBatis XML ファイルのパス          |
| タグ名       | `<select>`, `<insert>` などのタグ名 |
| ID           | SQL タグの ID                       |
| テーブル名   | SQL 文で使用されるテーブル名        |
| テーブル種別 | TABLE / VIEW                        |
| カラム名     | SELECT 句や WHERE 句のカラム名      |
| 条件式       | WHERE 句や JOIN 句の条件式          |
| 条件の出典   | `<sql>`や`<include>`の参照元        |

---

## **3. 差分解析と CRUD 図更新フロー**

1. **差分取得**：

   - Git コマンドで修正・追加された Java ファイルと XML ファイルを取得します。
   - 例:
     ```bash
     git diff --name-only HEAD~1 HEAD > changed_files.txt
     ```

2. **差分対象の CSV 生成**：

   - Java クラスや XML ファイルごとに個別の CSV を出力。
   - `changed_files.txt` のリストを基に、対象ファイルだけ CRUD 解析処理を実行します。

3. **CRUD 図の部分更新**：

   - 差分解析結果の CSV と既存の CRUD 図（全体 CSV）をマージ。
   - 差分ファイル単位で更新し、全体 CSV を最新化します。

4. **完全解析（週末）**：
   - すべての Java ファイルと XML を対象に完全解析を実行し、CRUD 図をリフレッシュ。

---

## **4. 出力管理とマージ処理**

### **ファイル単位の管理**

- Java クラスごとに**Logic/DAO 情報の CSV**を出力します。
- XML ファイルごとに**SQL 情報の CSV**を出力します。

### **CRUD 図のマージ処理**

- **クラス単位・ファイル単位**の出力 CSV を集約し、全体 CRUD 図を生成します。
- 以下の処理で重複を排除しながら統合します：
  - 同じ`Namespace`と`ID`のエントリを上書き。
  - 差分のみを新たに追加。

---

## **5. CI/CD パイプラインへの反映**

| **処理ステップ**        | **処理内容**                                         |
| ----------------------- | ---------------------------------------------------- |
| **Step 1**: 差分抽出    | Git で変更があった Java・XML ファイルを特定          |
| **Step 2**: 差分解析    | 変更ファイル単位で CRUD 情報の CSV を再生成          |
| **Step 3**: CRUD 図更新 | 差分 CSV と全体 CSV をマージし、最新状態に更新       |
| **Step 4**: 完全解析    | 週末に全ファイルを対象に CRUD 図を再生成（完全更新） |

---

## **まとめ**

- Java クラスと MyBatis XML を**ファイル単位**で CSV 出力する設計は、差分解析と完全解析を効率化します。
- 差分ファイルのみに CRUD 図更新処理を実行し、処理時間を大幅に短縮できます。
- 完全解析は週末に実行し、全体の CRUD 図を最新状態にリフレッシュします。

このアプローチにより、CI/CD パイプライン上での CRUD 図の管理が効率的かつ正確になります。
