CSV形式での出力に対応する場合の方針と実装を以下に示します。


---

CSV出力の方針

1. 出力形式の設計

CSV形式では、各XMLファイルやタグ、テーブル名、カラム名を行ごとに出力します。以下のような形式を想定します：

2. 実装の流れ

1. XMLファイルを解析： 既存のJSON形式の辞書データを利用し、各ファイル、タグ、テーブル名、カラム名を行ごとに展開。


2. CSV出力形式の作成： Pythonの標準ライブラリ csv を使用して、行単位で出力。


3. JSONとCSVの両対応： JSON形式の保存機能を維持しつつ、オプションとしてCSV形式の出力を追加。




---

改良版コード

以下にCSV出力を追加したコードを示します：

import os
import xml.etree.ElementTree as ET
import json
import csv
import re
import sqlparse

def parse_sql(sql):
    """
    SQL文を解析してテーブル名、カラム名、副問合せを抽出する。
    """
    tables = {}
    parsed = sqlparse.parse(sql)
    for stmt in parsed:
        tokens = sqlparse.sql.TokenList(stmt.tokens)

        # FROM句解析
        from_found = False
        table_name = None
        for token in tokens:
            if from_found and token.ttype is None:  # FROM句の後
                table_name = token.get_real_name()
                alias = token.get_alias()
                if table_name:
                    if alias:
                        tables[alias] = table_name
                    else:
                        tables[table_name] = []
                from_found = False
            
            if token.value.upper() == "FROM":
                from_found = True

            # SELECT内のカラム解析
            if token.ttype is None and token.value.upper().startswith("("):  # 副問合せの検出
                subquery = token.value
                sub_tables = parse_sql(subquery[1:-1])  # 再帰的解析
                tables.update(sub_tables)

            # WHERE句解析
            if token.value.upper() == "WHERE":
                condition = "".join(str(t) for t in tokens)
                columns_in_where = re.findall(r"([a-zA-Z0-9_]+)\s*=", condition)
                for col in columns_in_where:
                    if table_name:
                        tables[table_name].append(col)
    
    return tables

def parse_mybatis_xml(file_path):
    """
    MyBatisのXMLファイルを解析し、SQL文を抽出して解析する。
    """
    tree = ET.parse(file_path)
    root = tree.getroot()

    tables_by_tag = {
        "select": {},
        "resultMap": {}
    }

    # <select>タグの解析
    for select in root.findall(".//select"):
        sql = select.text.strip()
        sql_tables = parse_sql(sql)
        tables_by_tag["select"].update(sql_tables)
    
    # <resultMap>タグの解析
    for resultMap in root.findall(".//resultMap"):
        for result in resultMap.findall(".//result"):
            column = result.attrib.get('column')
            table_name = "unknown_table"  # 必要ならテーブル名を推測
            if table_name not in tables_by_tag["resultMap"]:
                tables_by_tag["resultMap"][table_name] = []
            tables_by_tag["resultMap"][table_name].append(column)
    
    return tables_by_tag

def save_to_json(data, output_path):
    """
    辞書をJSON形式で保存する。
    """
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

def save_to_csv(data, output_path):
    """
    辞書をCSV形式で保存する。
    """
    with open(output_path, 'w', encoding='utf-8', newline='') as f:
        writer = csv.writer(f)
        # ヘッダー行の書き込み
        writer.writerow(["ファイル名", "タグ", "テーブル名", "カラム名"])
        
        # データの展開と書き込み
        for file_name, tags in data.items():
            for tag, tables in tags.items():
                for table_name, columns in tables.items():
                    for column in columns:
                        writer.writerow([file_name, tag, table_name, column])

def main():
    input_dir = "./mybatis_xml"  # XMLファイルのディレクトリ
    json_output_file = "./tables_columns.json"
    csv_output_file = "./tables_columns.csv"
    all_files_data = {}

    # ディレクトリ内の全XMLファイルを解析
    for file_name in os.listdir(input_dir):
        if file_name.endswith(".xml"):
            file_path = os.path.join(input_dir, file_name)
            file_data = parse_mybatis_xml(file_path)
            all_files_data[file_name] = file_data
    
    # JSONファイルに保存
    save_to_json(all_files_data, json_output_file)
    print(f"JSONファイルに保存しました: {json_output_file}")

    # CSVファイルに保存
    save_to_csv(all_files_data, csv_output_file)
    print(f"CSVファイルに保存しました: {csv_output_file}")

if __name__ == "__main__":
    main()


---

改良ポイント

1. save_to_csv関数：

データを展開し、行単位でファイル名、タグ、テーブル名、カラム名をCSVに出力。



2. JSONとCSVの両形式に対応：

解析結果をJSON形式で保存すると同時に、CSV形式にも保存。



3. CSV出力のフォーマット：

ファイル名、タグ、テーブル名、カラム名を列に分けて出力。

日本語ヘッダーを設定。





---

出力例

CSVファイル内容

ファイル名,タグ,テーブル名,カラム名
file1.xml,select,example_table,column1
file1.xml,select,example_table,column2
file1.xml,resultMap,unknown_table,column3
file2.xml,select,yet_another_table,col_x
file2.xml,select,yet_another_table,col_y


---

まとめ

この改良により、解析結果をCSV形式でも出力可能になりました。

JSON形式は構造的なデータ解析やプログラム連携向け。

CSV形式は人間が見やすい形で簡単に結果を確認したり、Excelなどで加工する場合に適しています。


必要に応じて、JSON・CSVのどちらかを選択するオプションを追加することも可能です。

